\section{Herramientas}
Nuestra implementación para el cálculo de iluminación global en tiempo real está basada en la \ac{GPU}. Esta aplicación genera gráficos por computadora utilizando rasterización en tiempo real acelerado por hardware gráfico, para esto existen principalmente dos API gráficas, OpenGL y Direct3D. Para acceder a distintas características del hardware gráfico, rasterización y pipeline de renderizado se utilizó OpenGL junto al lenguaje de sombreado GLSL para el desarrollo de \emph{shaders}. 

La aplicación hace uso de características relativamente recientes en OpenGL como lectura y escritura arbitraria y operaciones atómicas sobre texturas utilizando la extensión ya mencionada en la sección \ref{sec:voxelizacion}. Esta extensión es parte del núcleo de OpenGL desde la versión 4.2. 

Otro aspecto importante de la aplicación es el uso de \ac{GPGPU} para distintos cálculos de iluminación, filtrado y sombreado sobre datos almacenados en volúmenes. El uso de \ac{GPGPU} nos permite realizar cálculo paralelo masivo utilizando núcleos dedicados en la \ac{GPU}. Para esto existen distintas alternativas como CUDA y OpenCL o recientemente \emph{compute shaders}. En nuestra aplicación se utilizaron \emph{compute shaders} que provee OpenGL desde la versión 4.3. Estos \emph{shaders} permiten cómputo general en la GPU con la sintaxis ya familiar de GLSL además de mayor compatibilidad en contraste con tecnologías como CUDA que solo están disponibles en tarjetas gráficas NVIDIA.

El lenguaje de desarrollo escogido fue C++ ya que este ofrece acceso directo al manejo de memoria similar al lenguaje C que está escrito OpenGL. Este acceso directo además ayuda a eliminar capas de abstracción sobre los datos que existen en otros lenguajes de más alto nivel. Esto puede ayudar a mejorar el rendimiento de la aplicación lo cual es importante para técnicas de renderizado en tiempo real. Otra razón importante por la que se escoge este lenguaje es que muchas herramientas utilizadas para facilitar el desarrollo de aplicaciones gráficas están escritas en este lenguaje. El entorno de desarrollo fue Visual Studio 2015 Community Edition en el sistema operativo Windows 10.

OpenGL necesita acceder al contexto o framebuffer de una ventana instanciada en algún sistema operativo para poder renderizar. Para la creación, manejo y acceso al contexto de ventanas se utilizó \emph{GLFW} versión 3.1.2. Para cargar las funciones de OpenGL, extensiones y enlazar el contexto se utilizó \emph{GLEW} en su versión 1.13.0. Para OpenGL en C++ a pesar de que se puede acceder directamente a sus funciones en crudo se utilizó un wrapper llamado \emph{OGLplus} en su versión 0.52.0. Este implementa una fachada orientada a objetos sobre OpenGL más acorde con el estilo de programación en C++. OGLplus provee administración automática de recursos y objetos de OpenGL, encapsulación y seguridad de tipos, manejo de errores e interoperabilidad con OpenGL en crudo. Para manejo de vectores y matrices además de otras funciones y operaciones matemáticas se utilizó la biblioteca GLM versión 0.9.7.

La aplicación hace uso de varios modelos, escenas tridimensionales y texturas, para estos recursos existen distintos formatos. Implementar soporte para una variedad de ellos es una tarea ardua por esto se utilizaron bibliotecas en C++ que ya proveen esta funcionalidad. Para la carga de mallas 3D e información de escena como cámaras, luces, materiales, jerarquía de objetos y texturas se utilizó la biblioteca \emph{Assimp} en su versión 3.2 por la variedad de formatos que soporta y las múltiples funciones que provee para pre-procesar los mallas e información de la escena. Para cargar datos en crudo de texturas se utilizó la biblioteca \emph{FreeImage}.

Para facilitar el uso de la aplicación esta provee una interfaz gráfica con acceso a distintas funciones relevantes a la manipulación de objetos en escena y parámetros del algoritmo de iluminación global. Para esto se utilizó la biblioteca \emph{dear imgui}, la cual provee distintas rutinas para la composición de interfaces de usuario, esta biblioteca utiliza el mismo pipeline de renderizado para dibujar la interfaz.
