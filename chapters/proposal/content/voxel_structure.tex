\section{Estructura Jerárquica} % (fold)
\label{sec:estructura_jerarquica}
Durante el trazado de conos se utilizan distintos niveles de detalle de la escena voxelizada a medida que el diámetro del cono se expande por su recorrido en escena. En el trabajo de Crassin estos niveles de detalle se construyen utilizando la profundidad del octree disperso, donde el nodo raiz es el nivel de detalle más bajo y las hojas del árbol contienen el máximo nivel detalle, el proceso de filtrado desde las hojas al nodo raíz fue explicado en la sección \ref{subsub:mipmaping_orig}. En nuestra implementación con texturas 3D esto representa simplemente los distintos niveles de mipmapping en una textura, estos puede ser generados con una sencilla llamada al metodo $glGenerateMipmap$ en OpenGL. Una ventaja de utilizar texturas 3D es que el filtrado cuadrilineal es soportado de forma nativa por hardware sin necesidad de construir bloques por cada vóxel como se explica en la sección \ref{subsub:voxelcontent_orig}. Esto simplifica de gran manera la construcción de la estructura jerárquica.
% section estructura_jerarquica (end)

\subsection{Mipmapping con Vóxeles Anisótropos} % (fold)
\label{sub:mipmapping_direccioanl}
Es posible obtener resultados más precisos durante el trazado de conos utilizando vóxeles direccionales o anisótropos. Como fue explicada la generación de los niveles mipmap en la sección anterior solo se obtiene vóxeles isótropos, esto quiere decir que estos poseen el mismo valor sin importar la dirección en la que son observados. Los problemas que puede ocasionar esta forma de representar los niveles de detalles fueron explicados en la sección \ref{subsub:aniso_voxels_orig}. En el trabajo de Crassin implementar filtrado direccional consiste en que cada vóxel almacena seis valores por cada eje direccional positivo y negativo. En nuestra implementación con texturas 3D esto se traduce en seis texturas 3D (una por cada dirección) a la mitad de la resolución del volumen original. Para realizar filtrado direccional de alto rendimiento utilizamos compute shaders, el algoritmo utilizando es el mismo descrito en el trabajo original de Crassin ya expuesto en la sección \ref{subsub:aniso_voxels_orig}.
% section mipmapping_direccioanl (end)
