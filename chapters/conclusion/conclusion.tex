\chapter{Conclusiones}
\label{chap:conclusion}
En este trabajo hemos estudiado distintos algoritmos para el cálculo de iluminación indirecta en tiempo real. Se ha implementado un aproximación inspirada en el trabajo de Crassin para el cálculo de iluminación indirecta utilizando vóxeles y trazado de conos \cite{CNSGE11b}. Este trabajo se basa en conceptos ya existentes como trazado de conos para ray tracing propuesto por Amanatides en 1984 \cite{Amanatides:1984:RTC:800031.808589}. El mayor problema de esta aproximación era que calcular la colisión entre un cono y polígonos es usualmente una operación muy compleja. El trabajo de Crassin salta este problema utilizando una representación simplificada de la escena en vóxeles. Por cada punto sobre una superficie se trazan conos para acumular la iluminación indirecta difusa y especular. Estos conos son trazados sobre la semiesfera orientada según la normal de este punto basándose en integración Monte Carlo. Esta acumulación es realizada utilizando muestreo sobre una estructura de vóxeles. A medida que el cono realiza su recorrido su diámetro se expande, el tamaño del volumen a muestrear por tanto aumenta. Para esto se utiliza una estructura de vóxeles piramidal inspirada en mipmapping.

Nuestra implementación provee de manera efectiva una aproximación para la iluminación indirecta de uno y dos rebotes de luz. Esta implementación comprende distintos fenómenos de iluminación como reflexión difusa, reflexión especular, oclusión ambiental, sombras suaves, sombras indirectas, mezclado de colores y materiales emisivos. A pesar de esto algunos defectos son de esperar al tratarse de aproximaciones. Los mayores problemas visuales surgen por discontinuidad entre vóxeles. Es posible obtener valores erróneos por distintas causas como longitud de marcha o errores de voxelización, esto usualmente ocasiona \emph{light leaking} o escape de luz en algunas partes ciertas escenas. Otro problema notable es la aparición de \emph{color banding} o bandas de colores sobre reflexiones especulares finas, esto es un error de muestreo sobre los vóxeles el cual puede solucionarse disminuyendo la longitud de marcha del cono, sin embargo esto implica un alto costo en rendimiento.

Este trabajo tiene algunas diferencias notables con respecto al trabajo de Crassin. La principal diferencia es el uso de texturas tridimensionales en vez de la estructura octree dispersa propuesta por el trabajo mencionado. Esto se hace para simplificar el algoritmo y por rendimiento, la desventaja es mayor consumo de memoria. Otra diferencia importante es la manera en la que se captura la iluminación directa sobre los vóxeles, en el trabajo mencionado esto se hace a través de mapas \emph{light-view} inspirado en \acl{RSM}. Nuestra implementación realiza sombreado e iluminación vóxeles utilizando compute shaders sin necesidad de mapas light-view, esto evita problemas de sincronización existentes en el trabajo de Crassin al utilizar mapas de alta resolución y además nos evita crear mapas por cada luz en escena. La desventaja es que perdemos el mapeo de sombras sobre los vóxeles y se utiliza más memoria para almacenar información de las normales en un volumen. Para el primer punto se propuso una sencilla solución que consiste en utilizar ray-tracing sobre el volumen para pruebas de oclusión. Y por último nuestra implementación también utiliza compute shaders para calcular iluminación global sobre los vóxeles permitiéndonos aproximar iluminación indirecta de dos rebotes durante el trazado de conos.

\section{Trabajos Futuros} % (fold)
\label{sec:trabajos_futuros}
Nuestra implementación provee buenos resultados tanto en calidad visual como en rendimiento sin embargo podría beneficiarse de con futuros estudios y ciertas mejoras en la aplicación. En nuestra implementación el método de voxelización utilizado es conservativo solo bordes, para solventar problemas de light-leaking explorar alternativas de voxelización solida (incluyendo voxeles internos en la geometría) podría ayudar a reducir estos problemas ya que este es causado usualmente por la opacidad de voxeles cercanos. Además de esto un esquema de voxelización solida también podría abrir la posibilidad a explorar otras técnicas de iluminación como objetos con transluminiscencia o scattering.

Un problema en nuestra propuesta es el consumo en memoria. Esto podría reducirse utilizando la estructura octree dispersa propuesta originalmente por Crassin, sin embargo esto trae un costo agregado para la construcción de esta estructura y su recorrido. Una posibilidad reciente es el uso de texturas dispersas, sin embargo las extensiones que proveen esta funcionalidad en OpenGL son muy recientes y para el momento de este trabajo los commits sobre estas texturas todavía se hacen del lado del CPU, lo cual puede ser muy lento cuando consideramos actualización dinámica de estas texturas.

El nivel de detalle de voxelización depende del volumen de voxelización y la resolución de la cuadricula de voxeles. Usualmente la información más relevante al usuario se encuentra cercana al observador. Esta cualidad se podría explotar para realizar voxelización por distintas cuadriculas donde las cuadriculas cercanas al observador proveen mayor nivel de detalle para la representación en vóxeles. Esto permitiría manejar escenas de gran escala con mayor facilidad. Existen ya algunos recursos relacionados a esto como volúmenes de voxeles en cascada \cite{McLaren:2015:TCL:2775280.2792546}.

El trazado de conos puede ser acelerado utilizando variadas técnicas para reducir el número de pixeles a muestrear. Una técnica sencilla es realizar el cálculo de iluminación indirecta en un paso a parte a menor resolución y luego integrar este resultado como un pos-proceso. Esto puede hacer que se pierda precisión especialmente en los bordes de la geometría en escena. Para estos casos se puede utilizar algún algoritmo de detección de bordes y realizar el trazado de conos a resolución completa en estos pixeles. Los problemas de color banding en la reflexión especular pueden ser solventados utilizando \emph{dithering} sobre la reflexión especular resultante en este pos-proceso.
% section trabajos_futuros (end)
